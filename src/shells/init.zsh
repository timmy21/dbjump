# dbjump shell integration for zsh
# Generated by: dbjump shell zsh

# Cache management for alias list
_DBJUMP_ALIASES_CACHE=()
_DBJUMP_CACHE_VALID=0

# Refresh alias cache using dbjump list command
function _dbjump_refresh_cache() {{
    if command -v dbjump >/dev/null 2>&1; then
        local output
        output=$(command dbjump list --format text 2>/dev/null)
        if [[ $? -eq 0 && -n "$output" ]]; then
            _DBJUMP_ALIASES_CACHE=(${{(f)output}})
            _DBJUMP_CACHE_VALID=1
            return 0
        fi
    fi
    _DBJUMP_CACHE_VALID=0
    return 1
}}

# Hook to refresh cache before each prompt
function _dbjump_precmd_hook() {{
    _dbjump_refresh_cache
}}

# Register the precmd hook
autoload -U add-zsh-hook
add-zsh-hook precmd _dbjump_precmd_hook

# Wrapper function with smart fzf integration
function dbjump() {{
    if [[ $# -eq 1 && ($1 == "connect" || $1 == "info") ]]; then
        _dbjump_fzf_select "$1"
        return $?
    fi
    command dbjump "$@"
}}

# fzf selector function
function _dbjump_fzf_select() {{
    local subcommand=$1
    if ! command -v fzf >/dev/null 2>&1; then
        echo "Error: fzf is not installed. Please install fzf or provide alias directly." >&2
        echo "Usage: dbjump $subcommand <alias>" >&2
        return 1
    fi
    local aliases=($(_dbjump_get_aliases))
    if [[ ${{#aliases[@]}} -eq 0 ]]; then
        echo "Error: No databases configured. Run 'dbjump init' first." >&2
        return 1
    fi
    local prompt_text="Select database"
    if [[ $subcommand == "connect" ]]; then
        prompt_text="Connect to"
    elif [[ $subcommand == "info" ]]; then
        prompt_text="Show info for"
    fi
    local selected=$(printf '%s\n' "${{aliases[@]}}" | fzf \
        --height 40% \
        --reverse \
        --border \
        --prompt="$prompt_text > " \
        --preview="command dbjump info {{}} 2>/dev/null || echo 'Loading...'" \
        --preview-window=right:50%:wrap \
        --bind='ctrl-/:toggle-preview')
    if [[ -n "$selected" ]]; then
        print -z "dbjump $subcommand $selected"
    fi
}}

# Completion function
_dbjump() {{
    local context state state_descr line
    typeset -A opt_args
    local subcmd="${{words[2]}}"
    _arguments -C \
        '1: :->subcommand' \
        '*::arg:->args'
    case $state in
        subcommand)
            local -a subcommands
            subcommands=(
                'connect:Connect to a database'
                'init:Initialize configuration file'
                'list:List all configured databases'
                'info:Show connection information for a database'
                'validate:Validate configuration file'
                'completions:Generate shell completions'
                'shell:Generate shell integration code'
            )
            _describe 'command' subcommands
            ;;
        args)
            local prev="${{words[CURRENT-1]}}"
            case $prev in
                connect|info)
                    local -a aliases
                    aliases=($(_dbjump_get_aliases))
                    if [[ ${{#aliases[@]}} -gt 0 ]]; then
                        _describe 'database alias' aliases
                    fi
                    ;;
                list)
                    _arguments '--format[Output format]:format:(text json)'
                    ;;
                init)
                    _arguments '--force[Overwrite existing configuration]'
                    ;;
                completions)
                    _arguments ':shell:(bash zsh fish)'
                    ;;
                shell)
                    _arguments '--cmd[Custom command name]:command:' ':shell:(zsh bash fish)'
                    ;;
            esac
            ;;
    esac
}}

compdef _dbjump dbjump

# Custom fzf completion for dbjump
_fzf_complete_dbjump() {{
    local tokens=(${{(z)LBUFFER}})
    local cmd="${{tokens[1]}}"
    local subcommand="${{tokens[2]}}"
    if [[ $subcommand != "connect" && $subcommand != "info" ]]; then
        return 1
    fi
    _fzf_complete "--height 40% --reverse --border --prompt='Select database > ' --preview='command dbjump info {{}} 2>/dev/null || echo Loading...' --preview-window=right:50%:wrap" "$@" < <(
        _dbjump_get_aliases
    )
}}

_fzf_complete_dbjump_post() {{
    local alias_name
    read -r alias_name
    echo -n "$alias_name"
}}

# Unified helper function to get aliases
_dbjump_get_aliases() {{
    if [[ $_DBJUMP_CACHE_VALID -eq 1 ]]; then
        printf '%s\n' "${{_DBJUMP_ALIASES_CACHE[@]}}"
        return 0
    fi
    if _dbjump_refresh_cache; then
        printf '%s\n' "${{_DBJUMP_ALIASES_CACHE[@]}}"
        return 0
    fi
    return 1
}}

# Quick alias '{cmd}' for 'dbjump connect'
function {cmd}() {{
    if [[ $# -eq 0 ]]; then
        _dbjump_fzf_select "connect"
        return $?
    fi
    command dbjump connect "$@"
}}

# Completion function for {cmd}
_{cmd}() {{
    local -a aliases
    aliases=($(_dbjump_get_aliases))
    if [[ ${{#aliases[@]}} -gt 0 ]]; then
        _describe 'database alias' aliases
    fi
}}

compdef _{cmd} {cmd}

# Custom fzf completion for {cmd}
_fzf_complete_{cmd}() {{
    _fzf_complete "--height 40% --reverse --border --prompt='Connect to > ' --preview='command dbjump info {{}} 2>/dev/null || echo Loading...' --preview-window=right:50%:wrap" "$@" < <(
        _dbjump_get_aliases
    )
}}

_fzf_complete_{cmd}_post() {{
    local alias_name
    read -r alias_name
    echo -n "$alias_name"
}}
